<canvas id="bubbleCanvas"></canvas>
<script>
    (function () {
        // Set up canvas and context
        const canvas = document.getElementById("bubbleCanvas");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ========================
        // Abstract Flowing Lines Background
        // ========================
        const flowingLines = [];
        const numFlowingLines = 20;

        // Initialize flowing lines
        for (let i = 0; i < numFlowingLines; i++) {
            flowingLines.push({
                yOffset: (i / numFlowingLines) * canvas.height,
                speed: 0.0003 + Math.random() * 0.0002,
                amplitude: 40 + Math.random() * 60,
                frequency: 0.002 + Math.random() * 0.003,
                phase: Math.random() * Math.PI * 2,
                verticalDrift: (Math.random() - 0.5) * 0.02
            });
        }

        function drawAbstractFlow(t, theme) {
            // Breathing effect with left-to-right sweep animation
            const breathCycle = (t * 0.00015) % 1; // 0 to 1 cycle (slower: ~110 seconds per cycle)
            let breatheOpacity;

            if (breathCycle < 0.15) {
                // Hidden for 15% of the time
                breatheOpacity = 0;
            } else {
                // Fade in and out smoothly in the remaining 85%
                const activeCycle = (breathCycle - 0.15) / 0.85; // Normalize to 0-1
                breatheOpacity = Math.sin(activeCycle * Math.PI); // Smooth fade in and out
            }

            // If fully transparent, skip drawing
            if (breatheOpacity < 0.01) {
                return;
            }

            // Left-to-right sweep progress (0 to 1) - slower sweep
            const sweepProgress = (t * 0.0008) % 1; // Slower sweep (~83 seconds)
            const sweepWidth = canvas.width * 0.4; // Width of the visible sweep area
            const sweepCenter = sweepProgress * canvas.width;

            ctx.save();

            // Draw flowing organic lines
            flowingLines.forEach((line, index) => {
                ctx.save();

                // Update vertical position with drift
                line.yOffset += line.verticalDrift;
                if (line.yOffset < -50) line.yOffset = canvas.height + 50;
                if (line.yOffset > canvas.height + 50) line.yOffset = -50;

                const points = [];
                const numPoints = 80;

                // Generate wavy line points
                for (let i = 0; i <= numPoints; i++) {
                    const progress = i / numPoints;
                    const x = progress * canvas.width;

                    // Simplified to 2 waves instead of 3 for better performance
                    const wave1 = Math.sin(progress * line.frequency * 10 + t * line.speed + line.phase);
                    const wave2 = Math.sin(progress * line.frequency * 15 - t * line.speed * 0.7);

                    const y = line.yOffset +
                             line.amplitude * wave1 * 0.6 +
                             line.amplitude * wave2 * 0.4;

                    points.push({ x, y });
                }

                // Draw the flowing line with sweep effect - optimized single gradient per line
                const hueVariation = (index / numFlowingLines) * 40;
                const baseHue = theme === 'light' ? 200 + hueVariation : 180 + hueVariation;

                // Set line style once per line instead of per segment
                ctx.lineWidth = 1.5 + (index % 3) * 0.5;
                ctx.lineCap = 'round';

                // Draw line in segments only where visible in sweep
                ctx.beginPath();
                let pathStarted = false;

                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const distanceFromSweep = Math.abs(point.x - sweepCenter);

                    if (distanceFromSweep < sweepWidth) {
                        const fadeProgress = 1 - (distanceFromSweep / sweepWidth);
                        const segmentOpacity = fadeProgress * breatheOpacity;

                        if (segmentOpacity > 0.01) {
                            if (!pathStarted) {
                                ctx.moveTo(point.x, point.y);
                                pathStarted = true;
                            } else {
                                ctx.lineTo(point.x, point.y);
                            }
                        } else {
                            pathStarted = false;
                        }
                    } else {
                        pathStarted = false;
                    }
                }

                // Apply single gradient and stroke once for entire visible portion
                const gradient = ctx.createLinearGradient(
                    sweepCenter - sweepWidth, line.yOffset,
                    sweepCenter + sweepWidth, line.yOffset
                );

                if (theme === 'light') {
                    gradient.addColorStop(0, `hsla(${baseHue}, 70%, 50%, 0)`);
                    gradient.addColorStop(0.5, `hsla(${baseHue}, 70%, 50%, ${breatheOpacity * 0.4})`);
                    gradient.addColorStop(1, `hsla(${baseHue}, 70%, 50%, 0)`);
                } else {
                    gradient.addColorStop(0, `hsla(${baseHue}, 85%, 60%, 0)`);
                    gradient.addColorStop(0.5, `hsla(${baseHue}, 85%, 60%, ${breatheOpacity * 0.35})`);
                    gradient.addColorStop(1, `hsla(${baseHue}, 85%, 60%, 0)`);
                }

                ctx.strokeStyle = gradient;
                ctx.stroke();

                ctx.restore();
            });

            // Add some abstract particles following the sweep - reduced count
            const numParticles = 8; // Reduced from 15
            for (let i = 0; i < numParticles; i++) {
                const particleX = sweepCenter + (Math.random() - 0.5) * sweepWidth * 0.5;
                const particleY = Math.random() * canvas.height;
                const size = 2 + Math.random() * 3;

                const distFromCenter = Math.abs(particleX - sweepCenter);
                const particleOpacity = (1 - distFromCenter / (sweepWidth * 0.5)) * breatheOpacity * 0.6;

                if (particleOpacity > 0.01) {
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, size, 0, Math.PI * 2);

                    if (theme === 'light') {
                        ctx.fillStyle = `hsla(220, 80%, 60%, ${particleOpacity})`;
                    } else {
                        ctx.fillStyle = `hsla(190, 90%, 70%, ${particleOpacity})`;
                    }

                    ctx.fill();
                }
            }

            ctx.restore();
        }

        // ========================
        // 3D Rotating Surface Background
        // ========================
        const gridRows = 80;
        const gridCols = 80;
        const grid3DSpacing = 120; // spacing between 3D grid points

        function vertexShader(x, y, z, m) {
            let x0 = m[0] * x + m[1] * y + m[2] * z + m[3];
            let y0 = m[4] * x + m[5] * y + m[6] * z + m[7];
            let z0 = m[8] * x + m[9] * y + m[10] * z + m[11];
            return [x0, y0, z0];
        }

        function projectPoint(pt) {
            const [x, y, z] = pt;
            const factor = 300 / (z + 300);
            const screenX = canvas.width / 2 + x * factor;
            const screenY = canvas.height / 2 - y * factor;
            return [screenX, screenY];
        }

        function draw3DSurface(t, m, theme) {
            let projectedPoints = [];
            let zValues = [];
            let minZ = Infinity;
            let maxZ = -Infinity;

            // First pass: calculate all points and find z-range
            for (let i = 0; i <= gridRows; i++) {
                projectedPoints[i] = [];
                zValues[i] = [];
                for (let j = 0; j <= gridCols; j++) {
                    // Center grid around 0
                    let x = (j - gridCols / 2) * grid3DSpacing;
                    let y = (i - gridRows / 2) * grid3DSpacing;
                    // Compute a dynamic z using a more interesting wave function
                    let frequency = 0.25, amplitude = 3;
                    let z = amplitude * Math.sin(frequency * x + t * 0.0008) * Math.cos(frequency * y + t * 0.0008);
                    zValues[i][j] = z;
                    minZ = Math.min(minZ, z);
                    maxZ = Math.max(maxZ, z);

                    let pt3d = vertexShader(x, y, z, m);
                    if (pt3d[2] < 1) {
                        projectedPoints[i][j] = null;
                    } else {
                        projectedPoints[i][j] = { screen: projectPoint(pt3d), depth: pt3d[2] };
                    }
                }
            }

            // Second pass: draw with depth-based styling
            ctx.save();

            for (let i = 0; i <= gridRows; i++) {
                for (let j = 0; j <= gridCols; j++) {
                    let ptData = projectedPoints[i][j];
                    if (!ptData) continue;

                    let pt = ptData.screen;
                    let depth = ptData.depth;

                    // Normalize z-value for coloring (0 to 1)
                    let zNorm = (zValues[i][j] - minZ) / (maxZ - minZ);

                    // Depth-based opacity (closer = more opaque)
                    let baseOpacity = Math.min(1, depth / 500);

                    // Depth-based line width (closer = thicker)
                    ctx.lineWidth = 0.4 + (baseOpacity * 1.2);

                    // Draw horizontal lines
                    if (j < gridCols && projectedPoints[i][j+1]) {
                        let nextPt = projectedPoints[i][j+1].screen;
                        let nextDepth = projectedPoints[i][j+1].depth;
                        let avgDepth = (depth + nextDepth) / 2;
                        let opacity = Math.min(1, avgDepth / 500) * 0.3;

                        // Create gradient based on height (z-value)
                        if (theme === 'light') {
                            // Cooler, more subtle colors for light mode
                            let hue = 200 + (zNorm * 60); // Blue to cyan
                            ctx.strokeStyle = `hsla(${hue}, 75%, 50%, ${opacity})`;
                        } else {
                            // Warmer, vibrant colors for dark mode
                            let hue = 170 + (zNorm * 90); // Cyan to purple
                            ctx.strokeStyle = `hsla(${hue}, 85%, 65%, ${opacity})`;
                        }

                        ctx.beginPath();
                        ctx.moveTo(pt[0], pt[1]);
                        ctx.lineTo(nextPt[0], nextPt[1]);
                        ctx.stroke();
                    }

                    // Draw vertical lines
                    if (i < gridRows && projectedPoints[i+1][j]) {
                        let nextPt = projectedPoints[i+1][j].screen;
                        let nextDepth = projectedPoints[i+1][j].depth;
                        let avgDepth = (depth + nextDepth) / 2;
                        let opacity = Math.min(1, avgDepth / 500) * 0.3;

                        // Create gradient based on height (z-value)
                        if (theme === 'light') {
                            let hue = 200 + (zNorm * 60);
                            ctx.strokeStyle = `hsla(${hue}, 75%, 50%, ${opacity})`;
                        } else {
                            let hue = 170 + (zNorm * 90);
                            ctx.strokeStyle = `hsla(${hue}, 85%, 65%, ${opacity})`;
                        }

                        ctx.beginPath();
                        ctx.moveTo(pt[0], pt[1]);
                        ctx.lineTo(nextPt[0], nextPt[1]);
                        ctx.stroke();
                    }
                }
            }

            // Add highlight lines at peaks and valleys
            ctx.lineWidth = 1.5;
            for (let i = 1; i < gridRows; i++) {
                for (let j = 1; j < gridCols; j++) {
                    let z = zValues[i][j];
                    let zNorm = (z - minZ) / (maxZ - minZ);

                    // Detect peaks (high points) and valleys (low points)
                    let isPeak = zNorm > 0.88;
                    let isValley = zNorm < 0.12;

                    if ((isPeak || isValley) && projectedPoints[i][j]) {
                        let ptData = projectedPoints[i][j];
                        let pt = ptData.screen;
                        let depth = ptData.depth;
                        let opacity = Math.min(1, depth / 500) * 0.5;

                        if (isPeak) {
                            // Bright highlights at peaks
                            ctx.strokeStyle = theme === 'light'
                                ? `hsla(270, 85%, 55%, ${opacity})`
                                : `hsla(280, 95%, 70%, ${opacity})`;
                        } else {
                            // Darker accents at valleys
                            ctx.strokeStyle = theme === 'light'
                                ? `hsla(190, 75%, 45%, ${opacity})`
                                : `hsla(180, 85%, 60%, ${opacity})`;
                        }

                        // Draw cross pattern at peaks/valleys
                        if (j < gridCols && projectedPoints[i][j+1]) {
                            ctx.beginPath();
                            ctx.moveTo(pt[0], pt[1]);
                            ctx.lineTo(projectedPoints[i][j+1].screen[0], projectedPoints[i][j+1].screen[1]);
                            ctx.stroke();
                        }
                    }
                }
            }

            ctx.restore();
        }

        // ========================
        // Bubble Animation Section
        // ========================
        const relatedClusters = [
            // Formal Verification & Specifications cluster
            ['formal-verification', 'model-checking', 'safety', 'liveness', 'temporal-logic', 'quint', 'specifications', 'testing', 'mbt'],

            // Kafka & Distributed Systems cluster
            ['apache-kafka', 'distributed-systems', 'replication', 'storage', 'tiered storage'],

            // DevOps & Monitoring cluster
            ['grafana', 'prometheus', 'monitoring', 'metrics', 'performance', 'strimzi', 'open feature', 'feature gates', 'integration'],

            // Deployment & Infrastructure cluster
            ['kubernetes', 'deployment', 'docker', 'containers', 'argo cd', 'continuous delivery', 'practical'],

            // Developer Tools cluster
            ['nvim', 'wezterm', 'sharship'],

            // Programming Languages cluster
            ['java', 'jdk-25', 'version 21', 'programming', 'programming language'],

            // AI & Learning cluster
            ['ai', 'chat gpt', 'machine learning', 'technology', 'learning', 'fundamentals', 'explained simple'],

            // Problem Solving cluster
            ['coding', 'problem solving', 'puzzles', 'dynamic programming'],

            // System Performance cluster
            ['linux', 'performance', 'metrics', 'monitoring']
        ];

        // Normalize categories for bubble generation.
        const normalizedMap = {};
        for (const [key, val] of Object.entries(categories)) {
            const lowerKey = key.toLowerCase();
            if (!normalizedMap[lowerKey]) {
                normalizedMap[lowerKey] = [];
            }
            normalizedMap[lowerKey].push(...val);
        }
        const categoryData = Object.entries(normalizedMap).map(([key, val]) => ({
            name: key,
            value: val.length,
        }));

        const colorPalettes = {
            light: [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
                '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B195', '#C06C84'
            ],
            dark: [
                'hsla(348, 100%, 70%, 0.7)', 'hsla(177, 70%, 70%, 0.7)', 'hsla(195, 66%, 70%, 0.7)',
                'hsla(24, 100%, 70%, 0.7)', 'hsla(155, 60%, 70%, 0.7)',
                'hsla(45, 90%, 70%, 0.7)', 'hsla(276, 56%, 70%, 0.7)', 'hsla(200, 65%, 70%, 0.7)',
                'hsla(15, 90%, 75%, 0.7)', 'hsla(340, 50%, 70%, 0.7)'
            ]
        };

        function getCurrentTheme() {
            const stored = localStorage.getItem("theme");
            if (stored === "light" || stored === "dark") return stored;
            return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
        }

        function generateBubbles(theme) {
            const palette = colorPalettes[theme];
            const bubbles = categoryData.map((cat, i) => {
                const radius = 35 + cat.value * 10;
                return {
                    name: cat.name,
                    value: cat.value,
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    squishX: 1,
                    squishY: 1,
                    radius,
                    baseRadius: radius,
                    color: palette[i % palette.length],
                    highlight: theme === 'light'
                        ? 'rgba(255, 255, 255, 0.3)'
                        : 'rgba(255, 255, 255, 0.5)',
                    fontColor: theme === 'light' ? '#111' : '#fff',
                    hovered: false,
                    hoverScale: 1,
                };
            });
            const bubbleMap = {};
            bubbles.forEach(b => {
                bubbleMap[b.name.toLowerCase()] = b;
            });
            const connections = [];
            relatedClusters.forEach(group => {
                for (let i = 0; i < group.length; i++) {
                    for (let j = i + 1; j < group.length; j++) {
                        const a = bubbleMap[group[i].toLowerCase()];
                        const b = bubbleMap[group[j].toLowerCase()];
                        if (a && b) {
                            connections.push({ a, b, progress: 0 });
                        }
                    }
                }
            });
            return { bubbles, connections };
        }

        let currentTheme = getCurrentTheme();
        let { bubbles, connections } = generateBubbles(currentTheme);
        let mouseX = -1000;
        let mouseY = -1000;

        // Mouse interaction
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            // Check if hovering over any bubble for cursor change
            let isOverBubble = false;
            for (let b of bubbles) {
                const dx = mouseX - b.x;
                const dy = mouseY - b.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < b.radius) {
                    isOverBubble = true;
                    break;
                }
            }
            canvas.style.cursor = isOverBubble ? 'pointer' : 'default';
        });

        canvas.addEventListener('mouseleave', () => {
            mouseX = -1000;
            mouseY = -1000;
            canvas.style.cursor = 'default';
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        function drawConnections(theme) {
            const t = Date.now();
            ctx.save();
            ctx.lineWidth = 2;

            connections.forEach((conn) => {
                const { a, b } = conn;
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Animated opacity
                const opacity = 0.15 + 0.1 * Math.sin(t * 0.001 + dist * 0.01);

                // Gradient line
                const gradient = ctx.createLinearGradient(a.x, a.y, b.x, b.y);
                gradient.addColorStop(0, theme === 'light'
                    ? `rgba(0, 0, 0, ${opacity})`
                    : `rgba(255, 255, 255, ${opacity})`);
                gradient.addColorStop(0.5, theme === 'light'
                    ? `rgba(100, 100, 255, ${opacity * 1.5})`
                    : `rgba(150, 150, 255, ${opacity * 1.5})`);
                gradient.addColorStop(1, theme === 'light'
                    ? `rgba(0, 0, 0, ${opacity})`
                    : `rgba(255, 255, 255, ${opacity})`);

                ctx.strokeStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.stroke();

                // Animated particle along the connection
                conn.progress += 0.005;
                if (conn.progress > 1) conn.progress = 0;

                const particleX = a.x + dx * conn.progress;
                const particleY = a.y + dy * conn.progress;

                ctx.beginPath();
                ctx.arc(particleX, particleY, 3, 0, 2 * Math.PI);
                ctx.fillStyle = theme === 'light'
                    ? `rgba(100, 100, 255, ${0.6})`
                    : `rgba(200, 200, 255, ${0.8})`;
                ctx.shadowColor = theme === 'light' ? 'rgba(100, 100, 255, 0.8)' : 'rgba(200, 200, 255, 1)';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            ctx.restore();
        }

        function drawBubble(bubble) {
            const effectiveRadius = bubble.radius * bubble.hoverScale;
            const theme = getCurrentTheme();

            // Outer glow/shadow
            ctx.save();
            ctx.shadowColor = bubble.color;
            ctx.shadowBlur = bubble.hovered ? 30 : 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Main bubble with enhanced glass morphism gradient
            const gradient = ctx.createRadialGradient(
                bubble.x - effectiveRadius * 0.3,
                bubble.y - effectiveRadius * 0.3,
                0,
                bubble.x,
                bubble.y,
                effectiveRadius
            );

            // Theme-aware gradient stops
            if (theme === 'light') {
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                gradient.addColorStop(0.2, bubble.color);
                gradient.addColorStop(0.7, bubble.color);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
            } else {
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(0.2, bubble.color);
                gradient.addColorStop(0.7, bubble.color);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
            }

            ctx.beginPath();
            ctx.ellipse(
                bubble.x,
                bubble.y,
                effectiveRadius * bubble.squishX,
                effectiveRadius * bubble.squishY,
                0,
                0,
                2 * Math.PI
            );
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();

            // Inner border/rim for depth with theme awareness
            ctx.save();
            ctx.globalAlpha = theme === 'light' ? 0.5 : 0.4;
            ctx.strokeStyle = theme === 'light'
                ? 'rgba(255, 255, 255, 0.8)'
                : 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = theme === 'light' ? 2.5 : 2;
            ctx.beginPath();
            ctx.ellipse(
                bubble.x,
                bubble.y,
                effectiveRadius * bubble.squishX * 0.93,
                effectiveRadius * bubble.squishY * 0.93,
                0,
                0,
                2 * Math.PI
            );
            ctx.stroke();
            ctx.restore();

            // Enhanced primary highlight (top-left)
            const highlightGradient = ctx.createRadialGradient(
                bubble.x - effectiveRadius * 0.4,
                bubble.y - effectiveRadius * 0.4,
                0,
                bubble.x - effectiveRadius * 0.4,
                bubble.y - effectiveRadius * 0.4,
                effectiveRadius * 0.5
            );

            if (theme === 'light') {
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                highlightGradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.6)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            } else {
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                highlightGradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.4)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            }

            ctx.beginPath();
            ctx.arc(
                bubble.x - effectiveRadius * 0.35,
                bubble.y - effectiveRadius * 0.35,
                effectiveRadius * 0.35,
                0,
                2 * Math.PI
            );
            ctx.fillStyle = highlightGradient;
            ctx.fill();

            // Secondary smaller highlight with theme adjustment
            ctx.beginPath();
            ctx.arc(
                bubble.x - effectiveRadius * 0.5,
                bubble.y - effectiveRadius * 0.25,
                effectiveRadius * 0.12,
                0,
                2 * Math.PI
            );
            ctx.fillStyle = theme === 'light'
                ? 'rgba(255, 255, 255, 0.85)'
                : 'rgba(255, 255, 255, 0.6)';
            ctx.fill();

            // Subtle bottom shadow for more depth
            const shadowGradient = ctx.createRadialGradient(
                bubble.x + effectiveRadius * 0.2,
                bubble.y + effectiveRadius * 0.3,
                0,
                bubble.x + effectiveRadius * 0.2,
                bubble.y + effectiveRadius * 0.3,
                effectiveRadius * 0.4
            );
            shadowGradient.addColorStop(0, theme === 'light'
                ? 'rgba(0, 0, 0, 0.15)'
                : 'rgba(0, 0, 0, 0.3)');
            shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.beginPath();
            ctx.arc(
                bubble.x + effectiveRadius * 0.2,
                bubble.y + effectiveRadius * 0.3,
                effectiveRadius * 0.3,
                0,
                2 * Math.PI
            );
            ctx.fillStyle = shadowGradient;
            ctx.fill();

            // Text with better styling
            ctx.save();
            ctx.fillStyle = bubble.fontColor;
            ctx.font = `bold ${Math.max(12, effectiveRadius * 0.25)}px 'JetBrains Mono', monospace`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Theme-aware text shadow for better readability
            if (theme === 'light') {
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            } else {
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
            }

            ctx.fillText(bubble.name.toUpperCase(), bubble.x, bubble.y);
            ctx.restore();
        }

        function update() {
            const t = Date.now();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the 3D rotating surface grid
            let ang = t / 1500;
            let s = Math.sin(ang);
            let c = Math.cos(ang);
            let mat = [
                c, 0, -s, 0,
                0, 1,  0, 0,
                s, 0,  c, 4 + 5 * Math.sin(t / 1500)
            ];
            draw3DSurface(t, mat, currentTheme);

            // Draw the abstract flowing lines on top
            drawAbstractFlow(t, currentTheme);

            let newTheme = getCurrentTheme();
            if (newTheme !== currentTheme) {
                currentTheme = newTheme;
                const result = generateBubbles(currentTheme);
                bubbles = result.bubbles;
                connections = result.connections;
            }
            drawConnections(currentTheme);

            const restitution = 0.85;
            // make it smooother :))
            const damping = 0.99999999998;

            // Check for hover and mouse interaction
            for (let b of bubbles) {
                const dx = mouseX - b.x;
                const dy = mouseY - b.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Mouse repulsion
                if (dist < 150 && dist > 0) {
                    const force = (150 - dist) / 150;
                    b.vx -= (dx / dist) * force * 2;
                    b.vy -= (dy / dist) * force * 2;
                }

                // Hover detection
                b.hovered = dist < b.radius;

                // Smooth hover scale transition
                const targetScale = b.hovered ? 1.15 : 1;
                b.hoverScale += (targetScale - b.hoverScale) * 0.1;
            }

            // Bubble-to-bubble collision with better physics
            for (let i = 0; i < bubbles.length; i++) {
                for (let j = i + 1; j < bubbles.length; j++) {
                    const b1 = bubbles[i];
                    const b2 = bubbles[j];
                    const dx = b2.x - b1.x;
                    const dy = b2.y - b1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = b1.radius + b2.radius;

                    if (dist < minDist && dist > 0) {
                        // Normalize collision vector
                        const nx = dx / dist;
                        const ny = dy / dist;

                        // Separate bubbles
                        const overlap = minDist - dist;
                        const separationX = nx * overlap * 0.5;
                        const separationY = ny * overlap * 0.5;

                        b1.x -= separationX;
                        b1.y -= separationY;
                        b2.x += separationX;
                        b2.y += separationY;

                        // Elastic collision response
                        const relVelX = b2.vx - b1.vx;
                        const relVelY = b2.vy - b1.vy;
                        const velAlongNormal = relVelX * nx + relVelY * ny;

                        if (velAlongNormal < 0) {
                            const impulse = velAlongNormal * restitution;
                            b1.vx += impulse * nx;
                            b1.vy += impulse * ny;
                            b2.vx -= impulse * nx;
                            b2.vy -= impulse * ny;

                            // Squish effect on collision
                            const collisionForce = Math.abs(velAlongNormal) / 10;
                            b1.squishX = Math.max(0.7, 1 - collisionForce);
                            b1.squishY = Math.min(1.3, 1 + collisionForce);
                            b2.squishX = Math.max(0.7, 1 - collisionForce);
                            b2.squishY = Math.min(1.3, 1 + collisionForce);
                        }
                    }
                }
            }

            // Update bubbles
            for (let b of bubbles) {
                const currentSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                const minSpeed = 0.6;

                // Apply damping only if speed is above minimum
                if (currentSpeed > minSpeed) {
                    b.vx *= damping;
                    b.vy *= damping;

                    // Ensure speed doesn't drop below minimum
                    const newSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                    if (newSpeed < minSpeed) {
                        const scale = minSpeed / newSpeed;
                        b.vx *= scale;
                        b.vy *= scale;
                    }
                } else {
                    // Maintain minimum speed
                    const scale = minSpeed / Math.max(currentSpeed, 0.01);
                    b.vx *= scale;
                    b.vy *= scale;
                }

                b.x += b.vx;
                b.y += b.vy;

                // Wall collisions
                if (b.x < b.radius) {
                    b.x = b.radius;
                    b.vx = Math.abs(b.vx) * restitution;
                    b.squishX = 0.75; b.squishY = 1.25;
                } else if (b.x > canvas.width - b.radius) {
                    b.x = canvas.width - b.radius;
                    b.vx = -Math.abs(b.vx) * restitution;
                    b.squishX = 0.75; b.squishY = 1.25;
                }
                if (b.y < b.radius) {
                    b.y = b.radius;
                    b.vy = Math.abs(b.vy) * restitution;
                    b.squishX = 1.25; b.squishY = 0.75;
                } else if (b.y > canvas.height - b.radius) {
                    b.y = canvas.height - b.radius;
                    b.vy = -Math.abs(b.vy) * restitution;
                    b.squishX = 1.25; b.squishY = 0.75;
                }

                // Smooth squish recovery
                b.squishX += (1 - b.squishX) * 0.15;
                b.squishY += (1 - b.squishY) * 0.15;

                // Gentle pulse animation
                const pulse = Math.sin(t * 0.002 + b.value) * 2;
                b.radius = b.baseRadius + pulse;

                drawBubble(b);
            }

            requestAnimationFrame(update);
        }

        update();
    }());
</script>