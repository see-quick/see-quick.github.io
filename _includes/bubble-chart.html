<canvas id="bubbleCanvas"></canvas>

<script>
    (function () {
        const relatedClusters = [
            ['formal-verification', 'model-checking', 'safety', 'distributed-systems', 'specifications'],
            ['strimzi', 'grafana', 'monitoring', 'metrics', 'performance', 'feature-gates', 'open feature', 'integration'],
            ['nvim', 'starship', 'wezterm', 'linux'],
            ['kubernetes', 'deployment', 'containers', 'docker', 'java', 'argo cd', 'tiered storage', 'version 21'],
            ['ai', 'chat gpt', 'machine learning']
        ];

        const normalizedMap = {};

        for (const [key, val] of Object.entries(categories)) {
            const lowerKey = key.toLowerCase();
            if (!normalizedMap[lowerKey]) {
                normalizedMap[lowerKey] = [];
            }
            normalizedMap[lowerKey].push(...val);
        }

        const categoryData = Object.entries(normalizedMap).map(([key, val]) => ({
            name: key,
            value: val.length,
        }));

        const colorPalettes = {
            light: [
                '#d32f2f', '#388e3c', '#1976d2', '#fbc02d', '#7b1fa2',
                '#0097a7', '#f57c00', '#c2185b', '#5d4037', '#303f9f'
            ],
            dark: [
                'hsla(0, 100%, 75%, 0.5)', 'hsla(140, 100%, 75%, 0.5)', 'hsla(210, 100%, 75%, 0.5)',
                'hsla(50, 100%, 75%, 0.5)', 'hsla(280, 100%, 75%, 0.5)',
                'hsla(180, 100%, 75%, 0.5)', 'hsla(20, 100%, 75%, 0.5)', 'hsla(330, 100%, 75%, 0.5)',
                'hsla(30, 100%, 75%, 0.5)', 'hsla(240, 100%, 75%, 0.5)'
            ]
        };

        function getCurrentTheme() {
            const stored = localStorage.getItem("theme");
            if (stored === "light" || stored === "dark") return stored;
            return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
        }

        const canvas = document.getElementById("bubbleCanvas");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let clusters = [];
        let soloBubbles = [];
        let connections = [];
        let currentTheme = getCurrentTheme();

        function generateBubbles(theme) {
            const palette = colorPalettes[theme];
            const used = new Set(relatedClusters.flat().map(s => s.toLowerCase()));
            const clusterData = [];
            const soloData = [];

            categoryData.forEach((cat, i) => {
                const radius = 35 + cat.value * 10;
                const base = {
                    name: cat.name,
                    value: cat.value,
                    radius,
                    baseRadius: radius,
                    color: palette[i % palette.length],
                    highlight: theme === 'light' ? 'rgba(255, 255, 255, 0.3)' : 'rgba(255, 255, 255, 0.5)',
                    fontColor: theme === 'light' ? '#111' : '#fff',
                    squishX: 1,
                    squishY: 1,
                };
                if (used.has(cat.name.toLowerCase())) {
                    clusterData.push(base);
                } else {
                    soloData.push({
                        ...base,
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4
                    });
                }
            });

            const clusters = relatedClusters.map((group, i) => {
                const cx = Math.random() * canvas.width;
                const cy = Math.random() * canvas.height;
                const members = group.map(name => clusterData.find(b => b.name.toLowerCase() === name.toLowerCase())).filter(Boolean);
                const center = members[0];
                if (!center) return null;
                center.x = cx;
                center.y = cy;
                center.vx = (Math.random() - 0.5) * 2;
                center.vy = (Math.random() - 0.5) * 2;

                const satellites = members.slice(1).map((b, idx) => {
                    return {
                        ...b,
                        color: center.color, // ðŸŒˆ inherit central bubble's color
                        baseRadius: Math.min(b.baseRadius, 20), // limit size
                        angle: Math.random() * Math.PI * 2,
                        dist: 100 + Math.random() * 40,
                        orbitSpeed: 0.01 + Math.random() * 0.01
                    };
                });

                return {
                    center,
                    satellites
                };
            }).filter(Boolean);

            const connections = [];
            clusters.forEach(cluster => {
                const center = cluster.center;
                cluster.satellites.forEach(satellite => {
                    connections.push({ a: center, b: satellite });
                });
            });

            return { clusters, soloBubbles: soloData, connections };
        }

        function drawConnections(theme) {
            ctx.save();
            ctx.lineWidth = 1;
            ctx.setLineDash([10, 0]);
            ctx.strokeStyle = theme === 'light' ?
                `rgba(0, 0, 0, ${0.10 + 0.05 * Math.sin(Date.now() * 0.002)})` :
                `rgba(255, 255, 255, ${0.10 + 0.05 * Math.sin(Date.now() * 0.002)})`;
            connections.forEach(({ a, b }) => {
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.stroke();
            });
            ctx.restore();
        }

        function drawBubble(bubble) {
            const gradient = ctx.createRadialGradient(
                bubble.x, bubble.y, bubble.radius * 0.9,
                bubble.x, bubble.y, bubble.radius
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.35)');
            gradient.addColorStop(0.5, bubble.color);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.03)');

            ctx.beginPath();
            ctx.ellipse(
                bubble.x,
                bubble.y,
                bubble.radius * bubble.squishX,
                bubble.radius * bubble.squishY,
                0,
                0,
                2 * Math.PI
            );
            ctx.fillStyle = gradient;
            ctx.shadowColor = bubble.color;
            ctx.shadowBlur = 4;
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.beginPath();
            ctx.arc(
                bubble.x - bubble.radius * 0.4,
                bubble.y - bubble.radius * 0.4,
                bubble.radius * 0.08,
                0,
                2 * Math.PI
            );
            ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.shadowBlur = 4;
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.beginPath();
            ctx.ellipse(
                bubble.x + bubble.radius * 0.2,
                bubble.y + bubble.radius * 0.1,
                bubble.radius * 0.3,
                bubble.radius * 0.15,
                Math.PI / 4,
                0,
                2 * Math.PI
            );

            ctx.fillStyle = bubble.fontColor;
            ctx.font = "bold 15px 'Comic Sans MS', cursive, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(bubble.name.toUpperCase(), bubble.x, bubble.y);
        }

        function update() {
            const newTheme = getCurrentTheme();
            const restitution = 0.98;

            if (newTheme !== currentTheme) {
                currentTheme = newTheme;
                const result = generateBubbles(currentTheme);
                clusters = result.clusters;
                soloBubbles = result.soloBubbles;
                connections = result.connections;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawConnections(currentTheme);

            const time = Date.now() * 0.001;

            clusters.forEach(cluster => {
                const c = cluster.center;
                c.x += c.vx;
                c.y += c.vy;

                if (c.x < c.radius || c.x > canvas.width - c.radius) c.vx *= -restitution;
                if (c.y < c.radius || c.y > canvas.height - c.radius) c.vy *= -restitution;

                drawBubble(c);

                cluster.satellites.forEach(s => {
                    s.angle += s.orbitSpeed;
                    s.x = c.x + Math.cos(s.angle) * s.dist;
                    s.y = c.y + Math.sin(s.angle) * s.dist;
                    s.radius = s.baseRadius + Math.sin(time * 2 + s.value) * 1.2;
                    drawBubble(s);
                });
            });

            soloBubbles.forEach(b => {
                b.x += b.vx;
                b.y += b.vy;
                if (b.x < b.radius || b.x > canvas.width - b.radius) b.vx *= -restitution;
                if (b.y < b.radius || b.y > canvas.height - b.radius) b.vy *= -restitution;
                b.radius = b.baseRadius + Math.sin(time * 2 + b.value) * 1.2;
                drawBubble(b);
            });

            requestAnimationFrame(update);
        }

        const result = generateBubbles(currentTheme);
        clusters = result.clusters;
        soloBubbles = result.soloBubbles;
        connections = result.connections;

        update();
    }());
</script>